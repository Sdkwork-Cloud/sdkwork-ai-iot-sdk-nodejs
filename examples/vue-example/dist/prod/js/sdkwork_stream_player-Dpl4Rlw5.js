import{aE as t,aG as e,aH as r,aI as s,aJ as i,aK as a}from"./index-ov3QC--c.js";class o{player=null;state=t.IDLE;volume=1;emitter=e();autoplayStatus=r.UNKNOWN;pendingPlayPromise=null;pendingPlayResolve=null;pendingPlayReject=null;config;constructor(e){this.config={decode:!1,sampleRate:16e3,realtime:!1,maxDelay:800,discardAll:!1,trafficImgUrl:"",channels:1,...e};try{this.initPlayer(),this.detectAutoplaySupport(),s.getInstance().onStatusChange(i.AUDIO,this.handleAutoplayStatusChange.bind(this))}catch(r){throw console.error("SdkworkStreamAudioPlayer 初始化失败:",r),this.setState(t.ERROR),r}}initPlayer(){if(!a.BufferStreamPlayer)throw console.error("缺少BufferStreamPlayer扩展文件，请确保已导入 recorder-core/src/extensions/buffer_stream.player"),new Error("BufferStreamPlayer扩展未加载，请检查导入路径");try{a.TrafficImgUrl=this.config.trafficImgUrl,this.player=a.BufferStreamPlayer({decode:this.config.decode,sampleRate:this.config.sampleRate,realtime:this.config.realtime,maxDelay:this.config.maxDelay,discardAll:this.config.discardAll,TrafficImgUrl:this.config.trafficImgUrl,onInputError:(t,e)=>{console.error(`第${e}次的音频片段输入出错: ${t}`),this.emitter.emit("onError",new Error(`音频片段输入出错: ${t}`))},onPlayEnd:()=>{console.log("音频播放结束"),this.setState(t.ENDED),this.emitter.emit("onEnd",null)}}),console.log("流式音频播放器实例已创建，配置:",this.config)}catch(e){throw console.error("流式音频播放器初始化失败:",e),this.emitter.emit("onError",e instanceof Error?e:new Error(String(e))),e}}async detectAutoplaySupport(t=!1){const e=await s.getInstance().detectMediaSupport(i.AUDIO,t);return this.autoplayStatus=e.status,e}async requestAutoplayPermission(t=!1){const e=await s.getInstance().requestPermission(i.AUDIO,t);return this.autoplayStatus=e.status,e}handleAutoplayStatusChange(t){this.autoplayStatus=t.status,this.emitter.emit("onAutoplayStatusChange",t)}async startStream(e,s){if(!this.player)throw new Error("流式音频播放器未初始化，请先创建播放器实例");return void 0!==e&&(this.config.sampleRate=e),void 0!==s&&(this.config.channels=s),this.state!==t.IDLE&&this.state!==t.ERROR&&await this.stopStream(),this.autoplayStatus===r.UNKNOWN&&await this.detectAutoplaySupport(),new Promise((e,s)=>{try{if(this.autoplayStatus===r.ALLOWED)this.player.start(()=>{console.log("流式音频播放器已启动"),this.setState(t.READY),this.emitter.emit("onPlay",null),e()},e=>{console.error("流式音频播放器启动失败:",e),this.setState(t.ERROR),this.emitter.emit("onError",new Error(e)),s(new Error(e))});else if(this.autoplayStatus===r.ALLOWED_MUTED){const r=this.volume;this.setVolume(0),this.player.start(()=>{console.log("流式音频播放器已启动(静音模式)"),this.setState(t.READY),this.emitter.emit("onPlay",null);const s=()=>{this.setVolume(r),document.removeEventListener("click",s),document.removeEventListener("touchstart",s),document.removeEventListener("keydown",s)};document.addEventListener("click",s),document.addEventListener("touchstart",s),document.addEventListener("keydown",s),e()},e=>{console.error("流式音频播放器启动失败:",e),this.setState(t.ERROR),this.emitter.emit("onError",new Error(e)),s(new Error(e))})}else{const r={status:this.autoplayStatus,requiresUserInteraction:!0,requiresMuted:!1};this.setState(t.WAITING_FOR_INTERACTION),this.emitter.emit("onAutoplayBlocked",r),this.pendingPlayPromise=new Promise((t,e)=>{this.pendingPlayResolve=t,this.pendingPlayReject=e});const i=e,a=s;this.pendingPlayPromise.then(()=>{i()}).catch(t=>{a(t)})}}catch(i){console.error("启动流式音频播放器失败:",i),this.setState(t.ERROR),this.emitter.emit("onError",i instanceof Error?i:new Error(String(i))),s(i)}})}async resumeAfterInteraction(){try{if(!this.player)throw new Error("流式音频播放器未初始化");if(this.state!==t.WAITING_FOR_INTERACTION)throw new Error("播放器不在等待用户交互状态");this.player.start(()=>{console.log("用户交互后流式音频播放器已启动"),this.setState(t.READY),this.emitter.emit("onPlay",null),this.pendingPlayResolve&&(this.pendingPlayResolve(),this.pendingPlayPromise=null,this.pendingPlayResolve=null,this.pendingPlayReject=null),this.detectAutoplaySupport(!0)},e=>{console.error("用户交互后流式音频播放器启动失败:",e),this.setState(t.ERROR),this.emitter.emit("onError",new Error(e)),this.pendingPlayReject&&(this.pendingPlayReject(new Error(e)),this.pendingPlayPromise=null,this.pendingPlayResolve=null,this.pendingPlayReject=null)})}catch(e){throw this.setState(t.ERROR),this.emitter.emit("onError",e instanceof Error?e:new Error(String(e))),this.pendingPlayReject&&(this.pendingPlayReject(e instanceof Error?e:new Error(String(e))),this.pendingPlayPromise=null,this.pendingPlayResolve=null,this.pendingPlayReject=null),e}}appendStreamData(e){if(this.player)if(this.state===t.READY||this.state===t.PLAYING||this.state===t.PAUSED)try{if(e instanceof Float32Array){const t=new Int16Array(e.length);for(let r=0;r<e.length;r++)t[r]=Math.max(-32768,Math.min(32767,Math.round(32767*e[r])));this.player.input(t)}else e instanceof Int16Array?this.player.input(e):e instanceof ArrayBuffer&&this.player.input(new Int16Array(e));this.state!==t.PLAYING&&this.setState(t.PLAYING)}catch(r){console.error("音频数据处理失败:",r),this.emitter.emit("onError",r instanceof Error?r:new Error(String(r)))}else console.warn("流式音频播放器未启动");else console.error("流式音频播放器未初始化，无法添加音频数据")}async stopStream(){if(this.player)try{this.state!==t.IDLE&&this.state!==t.ERROR?(this.player.stop&&this.player.stop(),this.setState(t.IDLE),this.emitter.emit("onStop",null)):console.warn("流式音频播放器未启动，无需停止")}catch(e){console.error("停止流式音频播放器失败:",e),this.emitter.emit("onError",e instanceof Error?e:new Error(String(e)))}else console.error("流式音频播放器未初始化，无法停止")}pause(e){if(this.player)if(this.state===t.READY||this.state===t.PLAYING||this.state===t.PAUSED)try{this.player.pause&&(this.player.pause(),this.setState(t.PAUSED),this.emitter.emit("onPause",null)),e&&this.clearInput()}catch(r){console.error("暂停流式音频播放器失败:",r),this.emitter.emit("onError",r instanceof Error?r:new Error(String(r)))}else console.warn("流式音频播放器未启动，无法暂停");else console.error("流式音频播放器未初始化，无法暂停")}clearInput(e){this.player?this.state===t.READY||this.state===t.PLAYING||this.state===t.PAUSED?this.player.clearInput(e):console.warn("流式音频播放器未启动，无法清空输入"):console.error("流式音频播放器未初始化，无法清空输入")}async resume(){if(this.player)if(this.state===t.READY||this.state===t.PLAYING||this.state===t.PAUSED)try{this.player.resume&&(this.player.resume(),this.setState(t.PLAYING),this.emitter.emit("onPlay",null))}catch(e){console.error("恢复流式音频播放器失败:",e),this.emitter.emit("onError",e instanceof Error?e:new Error(String(e)))}else console.warn("流式音频播放器未启动，无法恢复");else console.error("流式音频播放器未初始化，无法恢复")}stop(){this.stopStream()}setVolume(t){this.player?(this.volume=Math.max(0,Math.min(1,t)),this.player.setVolume&&(this.player.setVolume(this.volume),this.emitter.emit("onVolumeChange",this.volume))):console.error("流式音频播放器未初始化，无法设置音量")}getVolume(){return this.volume}getState(){return this.state}isPlayable(){return this.state===t.READY||this.state===t.PLAYING||this.state===t.PAUSED}isRestartable(){return this.state===t.PLAYING||this.state===t.READY||this.state===t.PAUSED}setState(t){if(this.state!==t){const e=this.state;this.state=t,this.emitter.emit("onStateChange",{oldState:e,newState:t})}}on(t,e){this.emitter.on(t,e)}off(t){this.emitter.off(t)}destroy(){try{this.stopStream(),this.player&&this.player.destroy&&this.player.destroy(),this.player=null,this.emitter.all.clear(),this.setState(t.IDLE)}catch(e){console.error("销毁流式音频播放器失败:",e)}}}export{o as S};
